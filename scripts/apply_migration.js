const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
require('dotenv').config({ path: '.env.local' });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Error: Variables de entorno no configuradas');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

async function executeMigration() {
    try {
        console.log('üöÄ Iniciando migraci√≥n de ContaPyme...\n');
        
        // Leer el archivo de migraci√≥n
        const migrationPath = path.join(__dirname, '..', 'supabase', 'migrations', '20250908000000_estructura_modular_escalable.sql');
        
        if (!fs.existsSync(migrationPath)) {
            console.error('‚ùå Archivo de migraci√≥n no encontrado:', migrationPath);
            return false;
        }
        
        const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
        console.log('üìñ Archivo de migraci√≥n cargado exitosamente');
        console.log(`üìä Tama√±o de migraci√≥n: ${migrationSQL.length} caracteres`);
        
        // Dividir el SQL en sentencias individuales para ejecuci√≥n segura
        const statements = migrationSQL
            .split(';')
            .map(stmt => stmt.trim())
            .filter(stmt => stmt.length > 0 && !stmt.startsWith('--') && !stmt.startsWith('/*'));
        
        console.log(`üîß Ejecutando ${statements.length} sentencias SQL...\n`);
        
        let successCount = 0;
        let errorCount = 0;
        const errors = [];
        
        // Ejecutar cada sentencia individualmente usando rpc
        for (let i = 0; i < statements.length; i++) {
            const statement = statements[i].trim();
            if (statement.length === 0) continue;
            
            try {
                // Usar el cliente de Supabase para ejecutar SQL directo
                const { data, error } = await supabase.rpc('exec_sql', {
                    sql_query: statement
                });
                
                if (error) {
                    console.log(`‚ö†Ô∏è  Sentencia ${i + 1}: ${error.message}`);
                    errors.push({ statement: i + 1, error: error.message });
                    errorCount++;
                } else {
                    successCount++;
                    if (i % 50 === 0) {
                        console.log(`‚úÖ Procesadas ${i + 1} sentencias...`);
                    }
                }
                
                // Peque√±o delay para no sobrecargar la API
                if (i % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
            } catch (error) {
                console.log(`‚ùå Sentencia ${i + 1} error: ${error.message}`);
                errors.push({ statement: i + 1, error: error.message });
                errorCount++;
            }
        }
        
        console.log(`\nüìä Resumen de migraci√≥n:`);
        console.log(`  ‚úÖ Sentencias exitosas: ${successCount}`);
        console.log(`  ‚ùå Sentencias fallidas: ${errorCount}`);
        
        if (errors.length > 0 && errors.length < 10) {
            console.log(`\n‚ö†Ô∏è  Errores encontrados:`);
            errors.forEach(err => {
                console.log(`   ${err.statement}: ${err.error}`);
            });
        }
        
        return errorCount < statements.length * 0.1; // Considerar exitosa si menos del 10% falla
        
    } catch (error) {
        console.error('‚ùå Error ejecutando migraci√≥n:', error.message);
        return false;
    }
}

async function verifyTables() {
    console.log('\nüîç Verificando creaci√≥n de tablas...');
    
    const expectedTables = [
        'companies', 'users', 'company_settings', 'chart_of_accounts', 
        'journal_entries', 'journal_entry_lines', 'f29_analyses', 'f29_line_items',
        'employees', 'employment_contracts', 'contract_modifications', 'payroll_liquidations',
        'economic_indicators', 'digital_signatures', 'signature_verifications',
        'rcv_entities', 'fixed_assets', 'audit_logs'
    ];
    
    const foundTables = [];
    const missingTables = [];
    
    // Verificar cada tabla individualmente usando el cliente de Supabase
    for (const tableName of expectedTables) {
        try {
            const { data, error } = await supabase
                .from(tableName)
                .select('*')
                .limit(1);
                
            if (!error) {
                foundTables.push(tableName);
                console.log(`  ‚úÖ ${tableName}`);
            } else if (error.code === 'PGRST106' || error.message.includes('does not exist')) {
                missingTables.push(tableName);
                console.log(`  ‚ùå ${tableName} - NO EXISTE`);
            } else {
                // Tabla existe pero hay otro error (probablemente permisos o RLS)
                foundTables.push(tableName);
                console.log(`  ‚úÖ ${tableName} (existe pero RLS activo)`);
            }
        } catch (error) {
            missingTables.push(tableName);
            console.log(`  ‚ùå ${tableName} - ERROR: ${error.message}`);
        }
    }
    
    console.log(`\nüìä Resumen de verificaci√≥n de tablas:`);
    console.log(`  ‚úÖ Encontradas: ${foundTables.length} tablas`);
    console.log(`  ‚ùå Faltantes: ${missingTables.length} tablas`);
    
    // Verificar espec√≠ficamente las tablas cr√≠ticas mencionadas en el error
    const criticalTables = ['employees', 'payroll_liquidations'];
    console.log('\nüéØ Tablas cr√≠ticas para resolver errores de aplicaci√≥n:');
    criticalTables.forEach(tableName => {
        if (foundTables.includes(tableName)) {
            console.log(`  ‚úÖ ${tableName} - EXISTE (error de aplicaci√≥n deber√≠a resolverse)`);
        } else {
            console.log(`  ‚ùå ${tableName} - FALTA (error de aplicaci√≥n persistir√°)`);
        }
    });
    
    // Mostrar tablas faltantes si hay pocas
    if (missingTables.length > 0 && missingTables.length < 10) {
        console.log('\nüìù Tablas faltantes:');
        missingTables.forEach(name => console.log(`  - ${name}`));
    }
    
    return foundTables;
}

async function createExecSQLFunction() {
    console.log('üîß Creando funci√≥n de ejecuci√≥n SQL...');
    
    const createFunctionSQL = `
        CREATE OR REPLACE FUNCTION exec_sql(sql_query text)
        RETURNS text
        LANGUAGE plpgsql
        SECURITY DEFINER
        AS $$
        BEGIN
            EXECUTE sql_query;
            RETURN 'SUCCESS';
        EXCEPTION
            WHEN OTHERS THEN
                RETURN 'ERROR: ' || SQLERRM;
        END;
        $$;
    `;
    
    try {
        // Intentar crear la funci√≥n usando una consulta SQL directa
        const { data, error } = await supabase.rpc('exec_sql', {
            sql_query: createFunctionSQL
        });
        
        if (error) {
            console.log('‚ö†Ô∏è No se pudo crear funci√≥n exec_sql, intentando m√©todo alternativo...');
            return false;
        }
        
        console.log('‚úÖ Funci√≥n exec_sql creada exitosamente');
        return true;
    } catch (error) {
        console.log('‚ö†Ô∏è Funci√≥n exec_sql no disponible, usando m√©todo alternativo...');
        return false;
    }
}

async function executeAlternativeMigration() {
    console.log('üîÑ Ejecutando migraci√≥n usando m√©todo alternativo...');
    
    try {
        // Leer el archivo de migraci√≥n
        const migrationPath = path.join(__dirname, '..', 'supabase', 'migrations', '20250908000000_estructura_modular_escalable.sql');
        const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
        
        // Extraer solo las sentencias CREATE TABLE m√°s importantes
        const createTableStatements = migrationSQL.match(/CREATE TABLE[^;]+;/gi) || [];
        
        console.log(`üîß Creando ${createTableStatements.length} tablas principales...`);
        
        let successCount = 0;
        const criticalTables = ['companies', 'users', 'employees', 'payroll_liquidations'];
        
        for (const statement of createTableStatements) {
            try {
                // Ejecutar usando una funci√≥n PL/pgSQL simple
                const { data, error } = await supabase.rpc('exec_sql', {
                    sql_query: statement
                });
                
                if (!error || error.message.includes('already exists')) {
                    successCount++;
                    
                    // Extraer nombre de tabla
                    const match = statement.match(/CREATE TABLE\s+(\w+)/i);
                    if (match) {
                        const tableName = match[1];
                        console.log(`  ‚úÖ ${tableName}`);
                    }
                }
            } catch (err) {
                console.log(`  ‚ö†Ô∏è Error en sentencia: ${err.message}`);
            }
        }
        
        console.log(`‚úÖ Creadas ${successCount} de ${createTableStatements.length} tablas`);
        return successCount > 0;
        
    } catch (error) {
        console.error('‚ùå Error en migraci√≥n alternativa:', error.message);
        return false;
    }
}

async function main() {
    console.log('üöÄ Iniciando proceso de migraci√≥n de ContaPyme...\n');
    
    // Intentar crear la funci√≥n de ejecuci√≥n primero
    const functionCreated = await createExecSQLFunction();
    
    let migrationSuccess = false;
    
    if (functionCreated) {
        // Ejecutar migraci√≥n completa
        migrationSuccess = await executeMigration();
    } else {
        // Usar m√©todo alternativo
        migrationSuccess = await executeAlternativeMigration();
    }
    
    if (migrationSuccess) {
        // Esperar un momento para que la migraci√≥n se complete
        console.log('\n‚è≥ Esperando que la migraci√≥n se complete...');
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // Verificar que las tablas se crearon
        const foundTables = await verifyTables();
        
        console.log('\nüéâ Proceso de migraci√≥n completado!');
        console.log(`üìä Se verificaron exitosamente ${foundTables.length} tablas`);
        
        if (foundTables.includes('employees') && foundTables.includes('payroll_liquidations')) {
            console.log('\n‚úÖ Las tablas cr√≠ticas existen - los errores de aplicaci√≥n deber√≠an resolverse!');
        } else {
            console.log('\n‚ö†Ô∏è Algunas tablas cr√≠ticas faltan - los errores de aplicaci√≥n pueden persistir');
        }
        
        console.log('\nüìã Para verificar la aplicaci√≥n, revisa si los errores de esquema han desaparecido.');
        
    } else {
        console.log('\n‚ùå La migraci√≥n fall√≥ - por favor revisa los errores arriba');
        console.log('üí° Tip: Puedes intentar ejecutar las sentencias CREATE TABLE manualmente');
    }
}

// Ejecutar la migraci√≥n
main().catch(error => {
    console.error('üí• Error fatal:', error.message);
    process.exit(1);
});